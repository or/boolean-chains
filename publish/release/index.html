<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN"
"http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en" xml:lang="en">
<head>
<!-- 2025-05-08 Thu 16:18 -->
<meta http-equiv="Content-Type" content="text/html;charset=utf-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Boolean Chains</title>
<meta name="author" content="Oliver Runge" />
<meta name="generator" content="Org Mode" />
<style type="text/css">
  #content { max-width: 60em; margin: auto; }
  .title  { text-align: center;
             margin-bottom: .2em; }
  .subtitle { text-align: center;
              font-size: medium;
              font-weight: bold;
              margin-top:0; }
  .todo   { font-family: monospace; color: red; }
  .done   { font-family: monospace; color: green; }
  .priority { font-family: monospace; color: orange; }
  .tag    { background-color: #eee; font-family: monospace;
            padding: 2px; font-size: 80%; font-weight: normal; }
  .timestamp { color: #bebebe; }
  .timestamp-kwd { color: #5f9ea0; }
  .org-right  { margin-left: auto; margin-right: 0px;  text-align: right; }
  .org-left   { margin-left: 0px;  margin-right: auto; text-align: left; }
  .org-center { margin-left: auto; margin-right: auto; text-align: center; }
  .underline { text-decoration: underline; }
  #postamble p, #preamble p { font-size: 90%; margin: .2em; }
  p.verse { margin-left: 3%; }
  pre {
    border: 1px solid #e6e6e6;
    border-radius: 3px;
    background-color: #f2f2f2;
    padding: 8pt;
    font-family: monospace;
    overflow: auto;
    margin: 1.2em;
  }
  pre.src {
    position: relative;
    overflow: auto;
  }
  pre.src:before {
    display: none;
    position: absolute;
    top: -8px;
    right: 12px;
    padding: 3px;
    color: #555;
    background-color: #f2f2f299;
  }
  pre.src:hover:before { display: inline; margin-top: 14px;}
  /* Languages per Org manual */
  pre.src-asymptote:before { content: 'Asymptote'; }
  pre.src-awk:before { content: 'Awk'; }
  pre.src-authinfo::before { content: 'Authinfo'; }
  pre.src-C:before { content: 'C'; }
  /* pre.src-C++ doesn't work in CSS */
  pre.src-clojure:before { content: 'Clojure'; }
  pre.src-css:before { content: 'CSS'; }
  pre.src-D:before { content: 'D'; }
  pre.src-ditaa:before { content: 'ditaa'; }
  pre.src-dot:before { content: 'Graphviz'; }
  pre.src-calc:before { content: 'Emacs Calc'; }
  pre.src-emacs-lisp:before { content: 'Emacs Lisp'; }
  pre.src-fortran:before { content: 'Fortran'; }
  pre.src-gnuplot:before { content: 'gnuplot'; }
  pre.src-haskell:before { content: 'Haskell'; }
  pre.src-hledger:before { content: 'hledger'; }
  pre.src-java:before { content: 'Java'; }
  pre.src-js:before { content: 'Javascript'; }
  pre.src-latex:before { content: 'LaTeX'; }
  pre.src-ledger:before { content: 'Ledger'; }
  pre.src-lisp:before { content: 'Lisp'; }
  pre.src-lilypond:before { content: 'Lilypond'; }
  pre.src-lua:before { content: 'Lua'; }
  pre.src-matlab:before { content: 'MATLAB'; }
  pre.src-mscgen:before { content: 'Mscgen'; }
  pre.src-ocaml:before { content: 'Objective Caml'; }
  pre.src-octave:before { content: 'Octave'; }
  pre.src-org:before { content: 'Org mode'; }
  pre.src-oz:before { content: 'OZ'; }
  pre.src-plantuml:before { content: 'Plantuml'; }
  pre.src-processing:before { content: 'Processing.js'; }
  pre.src-python:before { content: 'Python'; }
  pre.src-R:before { content: 'R'; }
  pre.src-ruby:before { content: 'Ruby'; }
  pre.src-sass:before { content: 'Sass'; }
  pre.src-scheme:before { content: 'Scheme'; }
  pre.src-screen:before { content: 'Gnu Screen'; }
  pre.src-sed:before { content: 'Sed'; }
  pre.src-sh:before { content: 'shell'; }
  pre.src-sql:before { content: 'SQL'; }
  pre.src-sqlite:before { content: 'SQLite'; }
  /* additional languages in org.el's org-babel-load-languages alist */
  pre.src-forth:before { content: 'Forth'; }
  pre.src-io:before { content: 'IO'; }
  pre.src-J:before { content: 'J'; }
  pre.src-makefile:before { content: 'Makefile'; }
  pre.src-maxima:before { content: 'Maxima'; }
  pre.src-perl:before { content: 'Perl'; }
  pre.src-picolisp:before { content: 'Pico Lisp'; }
  pre.src-scala:before { content: 'Scala'; }
  pre.src-shell:before { content: 'Shell Script'; }
  pre.src-ebnf2ps:before { content: 'ebfn2ps'; }
  /* additional language identifiers per "defun org-babel-execute"
       in ob-*.el */
  pre.src-cpp:before  { content: 'C++'; }
  pre.src-abc:before  { content: 'ABC'; }
  pre.src-coq:before  { content: 'Coq'; }
  pre.src-groovy:before  { content: 'Groovy'; }
  /* additional language identifiers from org-babel-shell-names in
     ob-shell.el: ob-shell is the only babel language using a lambda to put
     the execution function name together. */
  pre.src-bash:before  { content: 'bash'; }
  pre.src-csh:before  { content: 'csh'; }
  pre.src-ash:before  { content: 'ash'; }
  pre.src-dash:before  { content: 'dash'; }
  pre.src-ksh:before  { content: 'ksh'; }
  pre.src-mksh:before  { content: 'mksh'; }
  pre.src-posh:before  { content: 'posh'; }
  /* Additional Emacs modes also supported by the LaTeX listings package */
  pre.src-ada:before { content: 'Ada'; }
  pre.src-asm:before { content: 'Assembler'; }
  pre.src-caml:before { content: 'Caml'; }
  pre.src-delphi:before { content: 'Delphi'; }
  pre.src-html:before { content: 'HTML'; }
  pre.src-idl:before { content: 'IDL'; }
  pre.src-mercury:before { content: 'Mercury'; }
  pre.src-metapost:before { content: 'MetaPost'; }
  pre.src-modula-2:before { content: 'Modula-2'; }
  pre.src-pascal:before { content: 'Pascal'; }
  pre.src-ps:before { content: 'PostScript'; }
  pre.src-prolog:before { content: 'Prolog'; }
  pre.src-simula:before { content: 'Simula'; }
  pre.src-tcl:before { content: 'tcl'; }
  pre.src-tex:before { content: 'TeX'; }
  pre.src-plain-tex:before { content: 'Plain TeX'; }
  pre.src-verilog:before { content: 'Verilog'; }
  pre.src-vhdl:before { content: 'VHDL'; }
  pre.src-xml:before { content: 'XML'; }
  pre.src-nxml:before { content: 'XML'; }
  /* add a generic configuration mode; LaTeX export needs an additional
     (add-to-list 'org-latex-listings-langs '(conf " ")) in .emacs */
  pre.src-conf:before { content: 'Configuration File'; }

  table { border-collapse:collapse; }
  caption.t-above { caption-side: top; }
  caption.t-bottom { caption-side: bottom; }
  td, th { vertical-align:top;  }
  th.org-right  { text-align: center;  }
  th.org-left   { text-align: center;   }
  th.org-center { text-align: center; }
  td.org-right  { text-align: right;  }
  td.org-left   { text-align: left;   }
  td.org-center { text-align: center; }
  dt { font-weight: bold; }
  .footpara { display: inline; }
  .footdef  { margin-bottom: 1em; }
  .figure { padding: 1em; }
  .figure p { text-align: center; }
  .equation-container {
    display: table;
    text-align: center;
    width: 100%;
  }
  .equation {
    vertical-align: middle;
  }
  .equation-label {
    display: table-cell;
    text-align: right;
    vertical-align: middle;
  }
  .inlinetask {
    padding: 10px;
    border: 2px solid gray;
    margin: 10px;
    background: #ffffcc;
  }
  #org-div-home-and-up
   { text-align: right; font-size: 70%; white-space: nowrap; }
  textarea { overflow-x: auto; }
  .linenr { font-size: smaller }
  .code-highlighted { background-color: #ffff00; }
  .org-info-js_info-navigation { border-style: none; }
  #org-info-js_console-label
    { font-size: 10px; font-weight: bold; white-space: nowrap; }
  .org-info-js_search-highlight
    { background-color: #ffff00; color: #000000; font-weight: bold; }
  .org-svg { }
</style>
<style>body {font-size: large;}</style>
<link rel="icon" href="./boolean-chains-favicon.png" type="image/png">
<meta content="./boolean-chains-favicon.png" property="og:image">
<script type="text/x-mathjax-config">
    MathJax.Hub.Config({
        displayAlign: "center",
        displayIndent: "0em",

        "HTML-CSS": { scale: 1.0,
                        linebreaks: { automatic: "%LINEBREAKS" },
                        webFont: "mathjax-modern"
                       },
        SVG: {scale: 1.0,
              linebreaks: { automatic: "%LINEBREAKS" },
              font: "mathjax-modern"},
        NativeMML: {scale: 1.0},
        TeX: {  Macros: {
N: "\\mathbb{N}",
Z: "\\mathbb{Z}",
vector: "\\overrightarrow",
dcolvec: ["\\left(\\begin{matrix} #1 \\\\ #2 \\end{matrix}\\right)", 2],
tcolvec: ["\\left(\\begin{matrix} #1 \\\\ #2 \\ #3 \\end{matrix}\\right)", 3]
 }, equationNumbers: {autoNumber: "%AUTONUMBER"},
               MultLineWidth: "85%",
               TagSide: "right",
               TagIndent: ".8em"
             }
});
</script>
<script type="text/javascript"
        src="https://cdn.jsdelivr.net/npm/mathjax@3/es5/tex-mml-chtml.js"></script>
</head>
<body>
<div id="content" class="content">
<h1 class="title">Boolean Chains</h1>
<div id="table-of-contents" role="doc-toc">
<h2>Table of Contents</h2>
<div id="text-table-of-contents" role="doc-toc">
<ul>
<li><a href="#boolean-chains">1. Boolean Chains</a>
<ul>
<li><a href="#introduction">1.1. Introduction</a></li>
<li><a href="#starting-point">1.2. Starting point</a></li>
<li><a href="#hungry-search">1.3. Hungry search</a>
<ul>
<li><a href="#hungry-search-improving-performance">1.3.1. Improving performance</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#exhaustive-search">2. Searching for the optimal solution</a>
<ul>
<li><a href="#exhaustive-search-improving-performance">2.1. Improving performance</a></li>
<li><a href="#algorithm-s">2.2. Algorithm S</a></li>
<li><a href="#algorithm-a">2.3. Algorithm A</a></li>
<li><a href="#performance">2.4. Performance</a></li>
</ul>
</li>
<li><a href="#results">3. Results</a>
<ul>
<li><a href="#results-full">3.1. Full search</a></li>
<li><a href="#results-hungry">3.2. Hungry search</a></li>
<li><a href="#results-branching">3.3. Branching</a></li>
</ul>
</li>
<li><a href="#best-chains">4. Best chains</a>
<ul>
<li><a href="#10-digits">4.1. Seven-segment display for 10 digits</a></li>
<li><a href="#11-digits">4.2. Seven-segment display for 11 digits</a></li>
<li><a href="#12-digits">4.3. Seven-segment display for 12 digits</a></li>
<li><a href="#13-digits">4.4. Seven-segment display for 13 digits</a></li>
<li><a href="#14-digits">4.5. Seven-segment display for 14 digits</a></li>
<li><a href="#15-digits">4.6. Seven-segment display for 15 digits</a></li>
<li><a href="#16-digits">4.7. Seven-segment display for 16 digits</a></li>
<li><a href="#7.1.2-54">4.8. Exercise 7.1.2-54</a></li>
<li><a href="#7.1.2-59">4.9. Exercise 7.1.2-59</a></li>
</ul>
</li>
<li><a href="#source-code">5. Source code</a></li>
</ul>
</div>
</div>
<a href=".." style="position: fixed; top: 10px; left: 10px; background: #eee; padding: 5px 10px; border-radius: 5px; text-decoration: none;">Home</a>
<div id="outline-container-boolean-chains" class="outline-2">
<h2 id="boolean-chains"><span class="section-number-2">1.</span> Boolean Chains</h2>
<div class="outline-text-2" id="text-boolean-chains">
</div>
<div id="outline-container-introduction" class="outline-3">
<h3 id="introduction"><span class="section-number-3">1.1.</span> Introduction</h3>
<div class="outline-text-3" id="text-introduction">
<p>
In section 7.1.2 <a href="https://www.informit.com/store/art-of-computer-programming-volume-4a-combinatorial-9780201038040">The Art of Computer Programming Volume 4A</a> Knuth describes and
analyzes  boolean chains, which are defined for functions of \(n\) variables \(x_1,
x_2, ...  x_n\) as a sequence of operations \(x_i = x_{j(i)} \circ_i x_{k(i)}\) for
\(n+1 \leq i \leq n + r\), with \(1 \leq j(i) < i, 1 \leq k(i)\) and \(\circ_i\) being
any binary operation. He shows that it is sufficient to consider the binary
operations \(\land\), \(\lor\), \(\oplus\), \(<\) (bitwise), \(>\) (bitwise).
</p>

<p>
In <b>Synthesizing a good chain</b> he discusses finding short boolean chains for
given target functions, using the example of a 7-segment display for decimal
digits; each segment is controlled by a boolean functions of the four inputs of
a 4-bit decimal digit.
</p>
</div>
</div>
<div id="outline-container-starting-point" class="outline-3">
<h3 id="starting-point"><span class="section-number-3">1.2.</span> Starting point</h3>
<div class="outline-text-3" id="text-starting-point">
<p>
In order to find a reasonably short boolean chain Knuth describes Algorithm L
and Algorithm U, an extension of Algorithm L, which tracks a <i>footprint</i> for
each possible function. The footprint is a set of &ldquo;first operations&rdquo; that can be
achieved with \(n\) input variables and that are part of the shortest chains
generating a target function. This footprint can used as a heuristic to greedily
pick the next operation. The resulting chain including the new operation can be
used as an input for Algorithm U again, resulting in the next operation to pick,
etc., until the chain contains all target functions.
</p>

<p>
This approach generates a boolean chain of length 22 for the 7-segment decimal
digit display. Knuth also mentions that David Stevenson found a 21-step chain by
picking \(x_{10}\) non-greedily.
</p>

<p>
I was interested in trying to find an even shorter chain for the display.
</p>
</div>
</div>
<div id="outline-container-hungry-search" class="outline-3">
<h3 id="hungry-search"><span class="section-number-3">1.3.</span> Hungry search</h3>
<div class="outline-text-3" id="text-hungry-search">
<p>
I started by using Algorithm L and Algorithm U from exercise 7.1.2-11, but
instead of greedily picking the best instruction according to the footprint
heuristic for a given chain of length \(l\), I consider the top \(k_l\) best
instructions and recurse for each of them in a depth-first search with a
maximal depth. As the chain length grows, \(k_l\) becomes gradually smaller.
I call this <i>hungry search</i>, because it starts taking big bites, then smaller
and smaller bites until it is done.
</p>

<p>
The idea is that the first few instructions are less likely to be optimal when
chosen greedily, so we want to try more of them. But as the chain gets longer
the greedy algorithm does a good job of identifying the best next step, so we
try fewer and fewer alternatives at every length. This makes the search space
manageable.
</p>

<p>
The question then becomes: how do we sort the instructions at every step to
determine the &ldquo;top \(k_l\)&rdquo; ones to try? I&rsquo;ve considered three criteria in order
of relevance:
</p>
<ol class="org-ol">
<li>The minimal cost of all target functions containing the instruction in the
footprint. Lower is better, assume infinity if the instruction is not part of
the footprint for any target function.</li>
<li>The number of target function footprints that contain the instruction. Higher
is better.</li>
<li>The index of the instruction based on the order Algorithm U generated them
in. Some generation orders might be better than others, this could be a
heuristic in its own right, but I haven&rsquo; investigated this. I&rsquo;ve used the
order from Algorithm U in the book.</li>
</ol>

<p>
The book greedily picks the instruction that appears in most target
footprints, preferring a lower minimal cost. I experimented with ordering
by minimal cost first and then prefer a higher number of matching footprints.
To break ties I also ordered by the negative of the index of generated
instructions. That index depends on the order in which the instructions are
generated; so this criterion really only makes the order deterministic.
</p>

<p>
Here&rsquo;s pythonesque pseudo-code to illustrate the general approach. The
<code>complete()</code> function yields True if all target functions are fulfilled. And the
<code>sort()</code> function orders the instructions as outlined above.
</p>

<div class="org-src-container">
<pre class="src src-python"><span style="color: #56697A;"># </span><span style="color: #56697A;">the first 4 are irrelevant, as x1, x2, x3, x4 are given</span>
<span style="color: #6c71c4;">BYTE_SIZE</span> = [<span style="color: #d33682; font-weight: bold;">0</span>, <span style="color: #d33682; font-weight: bold;">0</span>, <span style="color: #d33682; font-weight: bold;">0</span>, <span style="color: #d33682; font-weight: bold;">0</span>, <span style="color: #d33682; font-weight: bold;">5</span>, <span style="color: #d33682; font-weight: bold;">5</span>, <span style="color: #d33682; font-weight: bold;">5</span>, <span style="color: #d33682; font-weight: bold;">5</span>, <span style="color: #d33682; font-weight: bold;">5</span>, <span style="color: #d33682; font-weight: bold;">3</span>, <span style="color: #d33682; font-weight: bold;">3</span>, <span style="color: #d33682; font-weight: bold;">3</span>, <span style="color: #d33682; font-weight: bold;">3</span>, <span style="color: #d33682; font-weight: bold;">1</span>, <span style="color: #d33682; font-weight: bold;">1</span>, <span style="color: #d33682; font-weight: bold;">1</span>, ...]

<span style="color: #859900; font-weight: bold;">def</span> <span style="color: #268bd2;">hungry_search</span>(chain):
    <span style="color: #859900; font-weight: bold;">if</span> complete(chain):
        <span style="color: #268bd2;">print</span>(chain)
        <span style="color: #859900; font-weight: bold;">return</span>

    <span style="color: #6c71c4;">next_instructions</span>, <span style="color: #6c71c4;">footprints</span>, <span style="color: #6c71c4;">minimal_costs</span> = algorithm_U(chain)
    sort(next_instructions, footprints, minimal_costs)
    <span style="color: #859900; font-weight: bold;">for</span> i <span style="color: #859900; font-weight: bold;">in</span> <span style="color: #268bd2;">range</span>(BITE_SIZE[<span style="color: #268bd2;">len</span>(chain)]):
         hungry_search(chain + [next_instructions[i]])

hungry_search([x1, x2, x3, x4])
</pre>
</div>

<p>
There are some ways to reduce the search space further, namely by providing a
maximal length and bailing out whenever it becomes clear that a solution can&rsquo;t
be found on the path we&rsquo;re on, but those are orthogonal improvements.
</p>

<p>
With bite sizes 5, 5, 5, 5, 5, 3, 3, 3, 3, 1, 1, &#x2026; this approach generated
several chains of length 20, one step shorter than the previously shortest chain
in the book, the first one:
</p>

\begin{aligned}
    x_5    &= x_2    \oplus x_3                   & \quad
    x_{12} &= x_5    \lor   x_9                   & \quad
    x_{19} &= x_1    \land  x_{14}                & \\

    x_6    &= x_1    \lor   x_5                   & \quad
    x_{13} &= x_{11} <      x_{12} = \overline{f} & \quad
    x_{20} &= x_9    \oplus x_{19} = \overline{a} & \\

    x_7    &= x_4    \oplus x_5                   & \quad
    x_{14} &= x_4    \land  x_{12}                & \quad
    x_{21} &= x_{10} \oplus x_{20}                & \\

    x_8    &= x_2    >      x_7                   & \quad
    x_{15} &= x_{13} \oplus x_{14}                & \quad
    x_{22} &= x_{17} >      x_{21}                & \\

    x_9    &= x_3    <      x_7                   & \quad
    x_{16} &= x_7    >      x_{15} = \overline{d} & \quad
    x_{23} &= x_{14} \oplus x_{22} = \overline{e} & \\

    x_{10} &= x_6    \lor   x_8    = g            & \quad
    x_{17} &= x_{11} \lor   x_{14}                & \quad
    x_{24} &= x_2    \oplus x_{22} = \overline{b} & \\

    x_{11} &= x_1    \oplus x_2                   & \quad
    x_{18} &= x_6    >      x_{17} = \overline{c} & \\
\end{aligned}

<p>
Let&rsquo;s use that chain as an example for the algorithm:
</p>

<p>
For the first step the following instructions are possible and ordered as
described, the top 10 are shown. The numbers in brackets are:
</p>
<ol class="org-ol">
<li>minimal cost of target functions containing the instruction in their
footprint</li>
<li>number of target footprints containing the instruction</li>
<li>the index in the array of all generated next instructions</li>
</ol>

<div class="org-src-container">
<pre class="src src-nil">  * x5 = x2 ^ x3 = 0011110000111100 [4 4 19]
    x5 = x3 &gt; x4 = 0010001000100010 [4 2 27]
    x5 = x2 &gt; x4 = 0000101000001010 [4 2 22]
    x5 = x1 ^ x3 = 0011001111001100 [5 4 9]
    x5 = x2 &amp; x3 = 0000001100000011 [5 3 15]
    --- bite size ---
    x5 = x1 &lt; x4 = 0101010100000000 [5 3 11]
    x5 = x3 &lt; x4 = 0100010001000100 [5 2 26]
    x5 = x2 &lt; x4 = 0101000001010000 [5 2 21]
    x5 = x2 | x3 = 0011111100111111 [5 2 18]
    x5 = x1 ^ x4 = 0101010110101010 [5 2 14]
    ...
</pre>
</div>

<p>
Of that list we&rsquo;ll consider the top 5, because 5 is the bite size for that
chain length. The top instruction has a minimal cost of 4, and of the
instructions that have minimal cost of 4 it also appears in 4 target function
footprints. In this case is the greedy algorithm also picks the same
instruction, because in its ordering it also ends up on top.
</p>

<p>
Having chosen the first instruction (indicated by the <code>*</code>) we recurse and
enumerate the next possible instructions, ordering them as before.
</p>

<div class="org-src-container">
<pre class="src src-nil">  * x6 = x1 | x5 = 0011110011111111 [3 3 18]
    x6 = x3 &gt; x4 = 0010001000100010 [3 1 31]
    x6 = x2 &gt; x4 = 0000101000001010 [3 1 26]
    x6 = x1 &lt; x4 = 0101010100000000 [4 4 11]
    x6 = x2 &lt; x4 = 0101000001010000 [4 2 25]
    --- bite size ---
    x6 = x1 ^ x2 = 0000111111110000 [4 2 4]
    x6 = x3 &lt; x4 = 0100010001000100 [4 1 30]
    x6 = x4 ^ x5 = 0110100101101001 [5 3 38]
    x6 = x4 &amp; x5 = 0001010000010100 [5 3 34]
    x6 = x2 ^ x4 = 0101101001011010 [5 3 28]
    ...
</pre>
</div>

<p>
Here we already see the hungry search diverge from the greedy search due to
different ordering. The greedy search would have chosen the 4th instruction \(x_6
= x_1 < x_4\), because it appears in 4 target footprints, in fact it&rsquo;s the only
one. However, three instructions beat it on the minimal cost, so in this
heuristic we&rsquo;ll look at them first.
</p>

<p>
We take the first one again and recurse.
</p>

<div class="org-src-container">
<pre class="src src-nil">    x7 = x3 &gt; x4 = 0010001000100010 [2 2 35]
    x7 = x2 &gt; x4 = 0000101000001010 [2 2 25]
  * x7 = x4 ^ x5 = 0110100101101001 [4 3 45]
    x7 = x4 &amp; x5 = 0001010000010100 [4 3 41]
    x7 = x1 &lt; x4 = 0101010100000000 [4 3 11]
    --- bite size ---
    x7 = x1 ^ x3 = 0011001111001100 [4 3 9]
    x7 = x3 &amp; x6 = 0011000000110011 [4 2 38]
    x7 = x2 &lt; x6 = 0011000011110000 [4 2 29]
    x7 = x2 &lt; x4 = 0101000001010000 [4 2 24]
    x7 = x1 ^ x2 = 0000111111110000 [4 2 4]
    ...
</pre>
</div>

<p>
Here we again picked the first one, recursed, searched for solutions, at some
point came back to this point, tried the second instruction, and finally picked
the third instruction, which turned out to be the one in which we found the
solution, so let&rsquo;s pick that one and move on to the next step.
</p>

<div class="org-src-container">
<pre class="src src-nil">    x8 = x3 &gt; x7 = 0001001000010010 [2 3 52]
    x8 = x3 &gt; x4 = 0010001000100010 [2 2 45]
  * x8 = x2 &gt; x7 = 0000011000000110 [2 2 40]
    x8 = x2 &gt; x4 = 0000101000001010 [2 1 30]
    x8 = x3 &amp; x6 = 0011000000110011 [3 1 47]
    --- bite size ---
    x8 = x1 ^ x3 = 0011001111001100 [3 1 9]
    x8 = x3 &lt; x7 = 0100100001001000 [4 3 51]
    x8 = x3 &amp; x7 = 0010000100100001 [4 3 50]
    x8 = x2 &lt; x7 = 0110000001100000 [4 3 39]
    x8 = x1 &lt; x4 = 0101010100000000 [4 3 11]
    ...
</pre>
</div>

<p>
Again we try the first two, find nothing, try the third, and so on. Here are the
lists at every chosen step that lead to the given solution. I&rsquo;ve also added
<code>[target]</code> whenever the result is a target function. It&rsquo;s interesting that the
first instruction of the next step would&rsquo;ve been a target function, but it was
not the step that yielded the solution, likely because it the instruction chosen
here would&rsquo;ve been outside of the bite size window in the next step, which drops
to 3 after this step. [Note: this chain would not have been found with the
culling after target functions, see under improvements. Which is a data point
against that optimization.]
</p>

<div class="org-src-container">
<pre class="src src-nil">    x9 = x6 | x8 = 0011111011111111 [1 1 84] [target]
    x9 = x3 &amp; x6 = 0011000000110011 [3 1 51]
    x9 = x1 ^ x3 = 0011001111001100 [3 1 9]
  * x9 = x3 &lt; x7 = 0100100001001000 [4 3 55]
    x9 = x3 &amp; x7 = 0010000100100001 [4 3 54]
    --- bite size ----
    x9 = x1 &lt; x4 = 0101010100000000 [4 3 11]
    x9 = x1 ^ x2 = 0000111111110000 [4 3 4]
    x9 = x6 &amp; x7 = 0010100001101001 [4 2 78]
    x9 = x3 &gt; x7 = 0001001000010010 [4 2 56]
    x9 = x2 &lt; x7 = 0110000001100000 [4 2 44]
    ...
</pre>
</div>

<p>
As mentioned, the bite size drops to 3 at this point.
</p>

<div class="org-src-container">
<pre class="src src-nil">  * x10 = x6 | x8 = 0011111011111111 [1 1 99] [target]
    x10 = x1 ^ x2 = 0000111111110000 [3 3 4]
    x10 = x5 | x9 = 0111110001111100 [3 2 91]
    --- bite size ---
    x10 = x4 ^ x9 = 0001110100011101 [3 2 86]
    x10 = x1 ^ x9 = 0100100010110111 [3 2 33]
    x10 = x6 &gt; x9 = 0011010010110111 [3 1 103]
    x10 = x3 &amp; x6 = 0011000000110011 [3 1 61]
    x10 = x1 ^ x3 = 0011001111001100 [3 1 9]
    x10 = x1 &lt; x4 = 0101010100000000 [4 2 11]
    x10 = x5 ^ x9 = 0111010001110100 [4 1 92]
    ...
</pre>
</div>

<div class="org-src-container">
<pre class="src src-nil">  * x11 = x1 ^  x2 = 0000111111110000 [3 3 4]
    x11 = x5 |  x9 = 0111110001111100 [3 2 100]
    x11 = x4 ^  x9 = 0001110100011101 [3 2 92]
    --- bite size ---
    x11 = x1 ^  x9 = 0100100010110111 [3 2 33]
    x11 = x9 &lt; x10 = 0011011010110111 [3 1 118]
    x11 = x6 &gt;  x9 = 0011010010110111 [3 1 112]
    x11 = x3 &amp; x10 = 0011001000110011 [3 1 76]
    x11 = x3 &amp;  x6 = 0011000000110011 [3 1 65]
    x11 = x1 ^  x3 = 0011001111001100 [3 1 9]
    x11 = x1 &lt;  x4 = 0101010100000000 [4 2 11]
    ...
</pre>
</div>

<div class="org-src-container">
<pre class="src src-nil">  * x12 =  x5 |  x9 = 0111110001111100 [2 2 108]
    x12 = x10 &amp; x11 = 0000111011110000 [3 2 149]
    x12 =  x6 &amp; x11 = 0000110011110000 [3 2 127]
    --- bite size ---
    x12 =  x1 &lt;  x4 = 0101010100000000 [3 2 10]
    x12 =  x9 &amp; x11 = 0000100001000000 [3 1 144]
    x12 =  x9 &lt; x10 = 0011011010110111 [3 1 141]
    x12 =  x6 &gt; x11 = 0011000000001111 [3 1 128]
    x12 =  x6 &gt;  x9 = 0011010010110111 [3 1 124]
    x12 =  x4 ^ x11 = 0101101010100101 [3 1 103]
    x12 =  x4 ^  x9 = 0001110100011101 [3 1 95]
    ...
</pre>
</div>

<div class="org-src-container">
<pre class="src src-nil">  * x13 = x11 &lt; x12 = 0111000000001100 [1 1 170] [target]
    x13 =  x4 &amp; x12 = 0101010001010100 [3 2 113]
    x13 = x11 &amp; x12 = 0000110001110000 [3 1 169]
    --- bite size ---
    x13 = x10 &amp; x11 = 0000111011110000 [3 1 165]
    x13 =  x9 &amp; x11 = 0000100001000000 [3 1 160]
    x13 =  x9 &lt; x10 = 0011011010110111 [3 1 157]
    x13 =  x8 | x12 = 0111111001111110 [3 1 155]
    x13 =  x7 &gt; x11 = 0110000000001001 [3 1 146]
    x13 =  x6 &gt; x11 = 0011000000001111 [3 1 138]
    x13 =  x6 &amp; x11 = 0000110011110000 [3 1 137]
</pre>
</div>

<div class="org-src-container">
<pre class="src src-nil">  * x14 =  x4 &amp; x12 = 0101010001010100 [3 3 126]
    --- bite size ---
    x14 = x11 &amp; x12 = 0000110001110000 [3 1 206]
    x14 = x10 &amp; x11 = 0000111011110000 [3 1 200]
    x14 =  x9 &amp; x11 = 0000100001000000 [3 1 192]
    x14 =  x9 &lt; x10 = 0011011010110111 [3 1 189]
    x14 =  x8 | x13 = 0111011000001110 [3 1 187]
    x14 =  x8 | x12 = 0111111001111110 [3 1 182]
    x14 =  x7 &gt; x13 = 0000100101100001 [3 1 174]
    x14 =  x7 &lt; x13 = 0001000000000100 [3 1 173]
    x14 =  x7 &amp; x13 = 0110000000001000 [3 1 172]
    ...
</pre>
</div>

<div class="org-src-container">
<pre class="src src-nil">  * x15 = x13 ^ x14 = 0010010001011000 [2 1 234]
    --- bite size ---
    x15 = x11 | x14 = 0101111111110100 [2 1 231]
    x15 = x10 &gt; x14 = 0010101010101011 [2 1 223]
    x15 =  x6 &gt; x14 = 0010100010101011 [2 1 175]
    x15 =  x6 &gt; x11 = 0011000000001111 [2 1 168]
    x15 =  x1 &amp; x14 = 0000000001010100 [2 1 44]
    x15 =  x9 &amp; x11 = 0000100001000000 [3 1 207]
    x15 =  x4 ^  x9 = 0001110100011101 [3 1 127]
    x15 =  x1 &lt;  x4 = 0101010100000000 [3 1 10]
    x15 = x13 | x14 = 0111010001011100 [infinity 0 233]
</pre>
</div>

<div class="org-src-container">
<pre class="src src-nil">  * x16 =  x7 &gt; x15 = 0100100100100001 [1 1 215] [target]
    --- bite size ---
    x16 = x11 | x14 = 0101111111110100 [2 1 267]
    x16 = x10 &gt; x14 = 0010101010101011 [2 1 259]
    x16 =  x6 &gt; x14 = 0010100010101011 [2 1 197]
    x16 =  x6 &gt; x11 = 0011000000001111 [2 1 191]
    x16 =  x1 &amp; x14 = 0000000001010100 [2 1 44]
    x16 =  x9 &amp; x11 = 0000100001000000 [3 1 240]
    x16 =  x4 ^  x9 = 0001110100011101 [3 1 142]
    x16 =  x1 &lt;  x4 = 0101010100000000 [3 1 10]
    x16 = x13 | x14 = 0111010001011100 [infinity 0 272]
    ...
</pre>
</div>

<div class="org-src-container">
<pre class="src src-nil">  * x17 = x11 | x14 = 0101111111110100 [2 1 295]
    --- bite size ---
    x17 = x10 &gt; x14 = 0010101010101011 [2 1 285]
    x17 =  x6 &gt; x14 = 0010100010101011 [2 1 218]
    x17 =  x6 &gt; x11 = 0011000000001111 [2 1 213]
    x17 =  x1 &amp; x14 = 0000000001010100 [2 1 44]
    x17 =  x9 &amp; x11 = 0000100001000000 [3 1 264]
    x17 =  x5 ^ x16 = 0111010100011101 [3 1 201]
    x17 =  x4 | x16 = 0101110101110101 [3 1 178]
    x17 =  x4 ^  x9 = 0001110100011101 [3 1 156]
    x17 =  x1 &gt;  x9 = 0000000010110111 [3 1 30]
</pre>
</div>

<div class="org-src-container">
<pre class="src src-nil">  * x18 =  x6 &gt; x17 = 0010000000001011 [1 1 246] [target]
    --- bite size ---
    x18 =  x1 &amp; x14 = 0000000001010100 [2 1 44]
    x18 =  x9 &amp; x17 = 0100100001000000 [3 1 313]
    x18 =  x9 &amp; x11 = 0000100001000000 [3 1 298]
    x18 =  x5 ^ x16 = 0111010100011101 [3 1 217]
    x18 =  x4 | x16 = 0101110101110101 [3 1 191]
    x18 =  x4 ^  x9 = 0001110100011101 [3 1 169]
    x18 =  x1 &gt;  x9 = 0000000010110111 [3 1 30]
    x18 =  x1 &lt;  x4 = 0101010100000000 [3 1 10]
    x18 = x16 ^ x17 = 0001011011010101 [infinity 0 357]
    ...
</pre>
</div>

<div class="org-src-container">
<pre class="src src-nil">  * x19 =  x1 &amp; x14 = 0000000001010100 [2 1 44]
    --- bite size ---
    x19 =  x9 &amp; x17 = 0100100001000000 [3 1 330]
    x19 =  x9 &amp; x11 = 0000100001000000 [3 1 315]
    x19 =  x5 ^ x16 = 0111010100011101 [3 1 228]
    x19 =  x4 | x16 = 0101110101110101 [3 1 199]
    x19 =  x4 ^  x9 = 0001110100011101 [3 1 177]
    x19 =  x1 &gt;  x9 = 0000000010110111 [3 1 30]
    x19 =  x1 &lt;  x4 = 0101010100000000 [3 1 10]
    x19 = x16 ^ x18 = 0110100100101010 [infinity 0 385]
    x19 = x16 | x18 = 0110100100101011 [infinity 0 384]
    ...
</pre>
</div>

<div class="org-src-container">
<pre class="src src-nil">  * x20 = x9 ^ x19 = 0100100000011100 [1 1 356] [target]
    --- bite size ---
    x20 = x9 &amp; x17 = 0100100001000000 [3 1 348]
    x20 = x9 &amp; x11 = 0000100001000000 [3 1 333]
    x20 = x7 &amp; x17 = 0100100101100000 [3 1 292]
    x20 = x7 &amp; x11 = 0000100101100000 [3 1 277]
    x20 = x5 ^ x16 = 0111010100011101 [3 1 238]
    x20 = x4 &gt; x19 = 0101010100000001 [3 1 216]
    x20 = x4 | x16 = 0101110101110101 [3 1 208]
    x20 = x4 ^  x9 = 0001110100011101 [3 1 186]
    x20 = x2 ^ x19 = 0000111101011011 [3 1 120]
    ...
</pre>
</div>

<div class="org-src-container">
<pre class="src src-nil">  * x21 = x10 ^ x20 = 0111011011100011 [3 2 395]
    --- bite size ---
    x21 = x17 &amp; x20 = 0100100000010100 [3 1 460]
    x21 = x16 ^ x20 = 0000000100111101 [3 1 458]
    x21 = x14 ^ x20 = 0001110001001000 [3 1 439]
    x21 = x14 &gt; x20 = 0001010001000000 [3 1 438]
    x21 = x12 &gt; x20 = 0011010001100000 [3 1 425]
    x21 = x12 ^ x16 = 0011010101011101 [3 1 419]
    x21 = x10 ^ x14 = 0110101010101011 [3 1 387]
    x21 =  x9 &amp; x17 = 0100100001000000 [3 1 373]
    x21 =  x9 &amp; x11 = 0000100001000000 [3 1 358]
    ...
</pre>
</div>

<div class="org-src-container">
<pre class="src src-nil">  * x22 = x17 &gt; x21 = 0000100100010100 [2 2 517]
    --- bite size ---
    x22 = x14 ^ x21 = 0010001010110111 [2 1 484]
    x22 = x19 &lt; x21 = 0111011010100011 [infinity 0 524]
    x22 = x18 ^ x21 = 0101011011101000 [infinity 0 523]
    x22 = x18 | x21 = 0111011011101011 [infinity 0 522]
    x22 = x18 ^ x20 = 0110100000010111 [infinity 0 521]
    x22 = x18 | x20 = 0110100000011111 [infinity 0 520]
    x22 = x18 | x19 = 0010000001011111 [infinity 0 519]
    x22 = x17 ^ x21 = 0010100100010111 [infinity 0 518]
    x22 = x17 &amp; x21 = 0101011011100000 [infinity 0 516]
    ...
</pre>
</div>

<div class="org-src-container">
<pre class="src src-nil">  * x23 = x14 ^ x22 = 0101110101000000 [1 1 522] [target]
    --- bite size ---
    x23 =  x2 ^ x22 = 0000011000011011 [1 1 146] [target]
    x23 = x20 ^ x22 = 0100000100001000 [infinity 0 570]
    x23 = x20 | x22 = 0100100100011100 [infinity 0 569]
    x23 = x19 ^ x22 = 0000100101000000 [infinity 0 568]
    x23 = x19 | x22 = 0000100101010100 [infinity 0 567]
    x23 = x19 &lt; x21 = 0111011010100011 [infinity 0 566]
    x23 = x18 | x22 = 0010100100011111 [infinity 0 565]
    x23 = x18 ^ x21 = 0101011011101000 [infinity 0 564]
    x23 = x18 | x21 = 0111011011101011 [infinity 0 563]
    ...
</pre>
</div>

<div class="org-src-container">
<pre class="src src-nil">  * x24 =  x2 ^ x22 = 0000011000011011 [1 1 151] [target]
    --- bite size ---
    x24 = x21 ^ x23 = 0010101110100011 [infinity 0 628]
    x24 = x20 ^ x23 = 0001010101011100 [infinity 0 627]
    x24 = x20 | x23 = 0101110101011100 [infinity 0 626]
    x24 = x20 &lt; x23 = 0001010101000000 [infinity 0 625]
    x24 = x20 ^ x22 = 0100000100001000 [infinity 0 624]
    x24 = x20 | x22 = 0100100100011100 [infinity 0 623]
    x24 = x19 ^ x23 = 0101110100010100 [infinity 0 622]
    x24 = x19 ^ x22 = 0000100101000000 [infinity 0 621]
    x24 = x19 | x22 = 0000100101010100 [infinity 0 620]
    ...
</pre>
</div>

<p>
After some more optimizations of the code, based on the program for the
exhaustive search (see below), bigger bite sizes were feasible. The hungry
search with bite sizes 10, 9, 8, 7, 6, 5, &#x2026; found several chains of length 19.
The first solution of that kind was:
</p>

\begin{aligned}
    x_5    &= x_3    <      x_4                   & \quad
    x_{12} &= x_1    \lor   x_{11}                & \quad
    x_{19} &= x_8    >      x_{18} = \overline{a} & \\

    x_6    &= x_3    \oplus x_4                   & \quad
    x_{13} &= x_7    \lor   x_{12} = g            & \quad
    x_{20} &= x_4    \oplus x_{14}                & \\

    x_7    &= x_2    \oplus x_3                   & \quad
    x_{14} &= x_7    >      x_{11}                & \quad
    x_{21} &= x_{16} <      x_{20} = \overline{e} & \\

    x_8    &= x_5    \lor   x_7                   & \quad
    x_{15} &= x_2    \oplus x_{14}                & \quad
    x_{22} &= x_{19} \oplus x_{20}                & \\

    x_9    &= x_1    \oplus x_2                   & \quad
    x_{16} &= x_9    <      x_{15} = \overline{c} & \quad
    x_{23} &= x_8    \oplus x_{22} = \overline{d} & \\

    x_{10} &= x_8    >      x_9    = \overline{f} & \quad
    x_{17} &= x_{12} \land  x_{15} = \overline{b} & \\

    x_{11} &= x_6    \oplus x_{10}                & \quad
    x_{18} &= x_{11} \oplus x_{16}                & \\
\end{aligned}

<p>
The instruction \(x_5 = x_3 < x_4\) is the 7th instruction in the order of the heuristic
heuristic, that&rsquo;s why it wasn&rsquo;t considered for a bite size of 5. This illustrates that
good solutions can easily be missed, if the &ldquo;right&rdquo; instruction is just outside
of the bite size window, which can happen at any chain length in the hungry
search.
</p>

<p>
With infinite bite sizes at every step the hungry search would become an
exhaustive search and find all optimal solutions. But as the bite sizes
increase, the search space increases rapidly, which in combination with the
expensive Algorithm U makes large bite sizes computationally infeasible.
</p>

<p>
A faster exhaustive search is described below, it doesn&rsquo;t use any heuristic,
because it looks at all relevant instructions anyway. That allows it to traverse
much larger search spaces.
</p>
</div>
<div id="outline-container-hungry-search-improving-performance" class="outline-4">
<h4 id="hungry-search-improving-performance"><span class="section-number-4">1.3.1.</span> Improving performance</h4>
<div class="outline-text-4" id="text-hungry-search-improving-performance">
<p>
The bigger search with bite sizes 10, 9, 8, etc. was possible due to a few
optimizations in the code. In particular these two strategies avoid large parts
of the search tree. The first is safe, the second runs the risk of missing
solutions.
</p>

<dl class="org-dl">
<dt>Cull based on unfulfilled targets</dt><dd>Let \(t = 7\) be the number of target functions and \(w\) the number of target
functions not yet contained in the chain we&rsquo;re currently looking at, then as
soon as we see a chain of length \(c\) with \(c + w = m\) we know every next step
must generate a target function. This means we don&rsquo;t have to run Algorithm U
again, we simply pick the first target function in the available instructions
and so on. Since the last few iterations are a big part of the computation,
this reduces the overall effort by a factor of about 2-4, well worth the extra
branching required for the check.</dd>
</dl>


<dl class="org-dl">
<dt>Cull after target function</dt><dd>If we encounter a target function at any length, then we can pick this
instruction and move on with the hungry search, but once we backtrack to the
original length we can stop this branch. The function needs to be picked at
some point anyway, so it might as well be now. There is a chance that picking
other instructions inside the same bite would result in different footprints
in future bites, potentially finding shorter chains, but the footprints are
just a heuristic anyway, and it is much more likely that the target function
would simply come up in the next iteration again, doubling our work.
\(x_9\) is an example where this optimization would&rsquo;ve missed a solution,
because we&rsquo;d have stopped after trying the first instruction, which was a
target function.</dd>
</dl>
</div>
</div>
</div>
</div>
<div id="outline-container-exhaustive-search" class="outline-2">
<h2 id="exhaustive-search"><span class="section-number-2">2.</span> Searching for the optimal solution</h2>
<div class="outline-text-2" id="text-exhaustive-search">
<p>
For the decimal display 7.1.2-(44) I noticed that these chains are short enough
to search the entire space of all possible chains up to length 11, as a solution
of that length exists (7.1.2-(45)). It turns out 11 is the optimum, and it
only can be reached if the single stray <i>don&rsquo;t-care</i> is 1. (From here on I
assume that single <i>don&rsquo;t-care</i> is actually a 1, because that&rsquo;s the case in the
initial problem and the shortest chain with 0 is 11 steps long. It&rsquo;s possible
that for 12 digits, 13 digits, etc. a shorter chain exists with 0 in that place,
but I didn&rsquo;t care about that.)
</p>

<p>
Based on this I&rsquo;ve tried to reduce the number of <i>don&rsquo;t-cares</i>, finding minimal
chains for a display for the first 11 digits <code>0123456789A</code>, then one for the
first 12 digits <code>0123456789Ab</code>, etc.
</p>
</div>
<div id="outline-container-exhaustive-search-improving-performance" class="outline-3">
<h3 id="exhaustive-search-improving-performance"><span class="section-number-3">2.1.</span> Improving performance</h3>
<div class="outline-text-3" id="text-exhaustive-search-improving-performance">
<p>
The search space for these chains grows rather quickly, but we can reduce it in
a few ways:
</p>

<ol class="org-ol">
<li>We estimate the length of the minimal chain to be just one or two more than
the best chain we already found for the display with one less digit; call
this maximal length \(m\).</li>

<li>Let \(t = 7\) be the number of target functions and \(w\) the number of target
functions not yet contained in the chain we&rsquo;re currently looking at, then as
soon as we see a chain of length \(c\) with \(c + w > m\) we can stop pursuing
this branch, because any chain fulfilling the remaining targets would exceed
length \(m\).</li>

<li><p>
A lot of equivalent chains can be found in different orders, which wastes a
lot of computation. I consider two chains equivalent if the set of the
functions they generate are equal. There are chains for which one or more
functions can be derived with two or more instructions based on previous
functions, but those variants can easily be generated from the set of
functions.
</p>

<p>
It is sufficient to apply every function \(f\) only at the shortest length it is
found in the current branch. That means if we are at \(c = 3\) and encounter,
say, \(f =\) 0110 1001 0110 1010 for the first time, then we apply it and
recurse to \(c + 1\).  If we afterwards pick a different function at the same
length \(c\) and  down the line \(f\) reappears, then we ignore it. Even if the
function results from a different instruction at that time, we could&rsquo;ve just
chosen \(f\) at length \(c\) and done the same steps afterwards for the same
complete chain length.
</p>

<p>
Once we backtrack to length \(c-1\), however, we must forget about all \(f\)
we&rsquo;ve applied at that length in this branch, because they might re-appear in
a different branch for the first time (in that branch) and there result in
different chains.
</p>

<p>
This property makes it very easy to maintain all new instructions in a single,
shared array, to which we only ever add at each level of recursion and then
move the length back on backtracking. We also can simply start at the
instruction following the last instruction applied at the previous recursion
level, automatically ensuring that we&rsquo;re not duplicating work.
</p>

<p>
A side effect of this is that the number of relevant branches at every chain
length usually goes down as we try more and more instructions at that length.
This is a minor challenge in trying to generate roughly equal chunks for
parallelization.
</p></li>

<li><p>
Newly generated instructions at every length will still duplicate some functions
we&rsquo;ve seen before, e.g. if we chose \(x_4 = x_1 \oplus x_2\), then \(x_4 \oplus
   x_1\) and \(x_4 \oplus x_2\) would be new instructions at the next length, but
they&rsquo;d duplicate \(x_2\) and \(x_1\) respectively. The same is true for any
function derived on a different path in the previous chain.
</p>

<p>
To ignore those duplicates we can maintain a bit set of all the functions
we&rsquo;ve already seen in the chain up to that point, and it turns out this can
be the same set we use for 3. to avoid revisiting functions down the line.
</p></li>

<li><p>
If we encounter a target function at any length, then we can try that one and
recurse, but after that the entire branch for that length can be culled. The
reason is that the target function we tried in the last loop now can&rsquo;t ever
be used again in other chains along this branch, making a complete chain
impossible. This is due to point 3.
</p>

<p>
Note: this optimization is dangerous for hungry search, because of the bite
sizes, but for the exhaustive search it is safe.
</p></li>
</ol>
</div>
</div>
<div id="outline-container-algorithm-s" class="outline-3">
<h3 id="algorithm-s"><span class="section-number-3">2.2.</span> Algorithm S</h3>
<div class="outline-text-3" id="text-algorithm-s">
<p>
This algorithm generates all unique boolean chains for inputs \(x_k\), \(1 \leq k
\leq n\), \(n \geq 2\) up to a maximum length of \(m\) in order to find boolean chains that
contain target functions \(f_k\), \(1 \leq k \leq t\).
Let the inputs be distinct from the target functions, otherwise just remove them
from the target functions.
</p>

<p>
The algorithm generates all relevant boolean chains in depth-first manner, but
all the data can be shared across the different lengths of the chain.
</p>

<p>
Let \(c\) be the length of the current chain at any time, including the \(n\)
inputs.
</p>

<p>
\(I(c)\) is a 0-based array of available functions that can be generated with the
instructions based on the functions in the chain so far for the current chain of
length \(c\). \(N(c)\) is the relevant length of that array.
</p>

<p>
\(C(i)\) is a 0-based array of indexes into \(I\), for each step
\(0 \leq i < c\) of the current chain of length \(c\). Therefore
\(I(C(0))\), \(I(C(1))\), \(I(C(2))\), &#x2026; is the actual chain.
</p>

<p>
\(S\) is a set of functions we&rsquo;ve seen already and don&rsquo;t need to try again in this
branch.
</p>

<p>
\(F = \{f_k \, | \, 1 \leq k \leq t\}\) is the set of target functions.
</p>

<p>
Finally, \(w(c)\) is the number of target functions not yet in the current chain of
length \(c\).
</p>

<p>
<b>S1.</b> [Initialize.] Set \(c \leftarrow n\) and \(w(c) \leftarrow |F|\) to count all
the target functions we have yet to discover. Also set \(I(k) \leftarrow
x_{k+1}\), and \(C(k) \leftarrow k\) for \(0 \leq k < n\).
</p>

<p>
Build possible instructions of all combinations of the first \(n-1\) inputs.
The instructions involving the \(n\text{-th}\) input will be added by the main loop.
First we set \(S \leftarrow \emptyset\) and \(N(0) \leftarrow n\) then for \(1 \leq k
< n\) we add new instructions with Algorithm <b>A</b> with input \(k\).
</p>

<p>
<b>S2.</b> [Cull search?] If \(c + w > m\) we can&rsquo;t win anymore, stop this branch and
go to <b>S8</b>.
</p>

<p>
<b>S3.</b> [Found solution?] If \(w(c) = 0\) we have found a solution, print it. Go to <b>S8</b>.
</p>

<p>
<b>S4.</b> [Add new possible instructions.] Run Algorithm <b>A</b> with input \(c\).
</p>

<p>
<b>S5.</b> [Prepare looping on the next instruction.] Set \(C(c) \leftarrow C(c-1)\),
because we don&rsquo;t need to try any instructions we already tried during the last step.
</p>

<p>
<b>S6.</b> [Pick the next instruction.] Set \(C(c) \leftarrow C(c) + 1\). If \(C(c) \geq
N(c)\) go to <b>S7</b>. Otherwise if \(C(c) \in F\) then we have found a new target
function, set \(w(c+1) \leftarrow w(c) - 1\) otherwise \(w(c+1) \leftarrow w(c)\).
Finally set \(c \leftarrow c + 1\) and go to <b>S2</b>.
</p>

<p>
<b>S7.</b> [Clean up function set.] Set \(S \leftarrow S - \{ I(j) \, | \, N(c-1) \leq j <
N(c)\}\) to forget about all the functions we&rsquo;ve seen at this chain length in this
branch.
</p>

<p>
<b>S8.</b> [Backtrack.] Set \(c \leftarrow c - 1\). If \(c < n\) terminate the algorithm,
otherwise go to <b>S6</b>.
</p>
</div>
</div>
<div id="outline-container-algorithm-a" class="outline-3">
<h3 id="algorithm-a"><span class="section-number-3">2.3.</span> Algorithm A</h3>
<div class="outline-text-3" id="text-algorithm-a">
<p>
This adds new possible instructions to the array \(I\) for a given chain \(C\) with
length \(l\), which is the input to the algorithm, given all the arrays set up in
Algorithm S.
</p>

<p>
<b>A1.</b> [Initialize.] Set \(N(l) \leftarrow N(l-1)\).
</p>

<p>
<b>A2.</b> [Loop on instructions.] Set \(h \leftarrow I(C(l))\) and for \(0 \leq j < l\),
set \(g \leftarrow I(C(j))\) and do step <b>A3</b> for \(f = g \, \& \, h\), \(f = g \, |
\, h\), \(f = g \oplus h\), \(f = \overline{g} \, \& \, h\), and \(f = g \, \& \,
\overline{h}\).
</p>

<p>
<b>A3.</b> [Add instruction if new.] If \(f \not\in S\) set \(S \leftarrow S \cup \{f\}\),
\(I(N(l)) \leftarrow f\), and \(N(l) \leftarrow N(l) + 1\).
</p>
</div>
</div>
<div id="outline-container-performance" class="outline-3">
<h3 id="performance"><span class="section-number-3">2.4.</span> Performance</h3>
<div class="outline-text-3" id="text-performance">
<p>
The latest version of this program generates around 510-530 million chains per
second on my MacBook Air 15" (M2, 2023). On AWS Batch with Fargate capacity on 1
vCPU it generates around 200-230 million chains per second; so about 51-59
thousand million chains per second across 256 jobs.
</p>

<p>
The program might be suitable for the GPU, but I have no experience with GPU
programming.
</p>
</div>
</div>
</div>
<div id="outline-container-results" class="outline-2">
<h2 id="results"><span class="section-number-2">3.</span> Results</h2>
<div class="outline-text-2" id="text-results">
</div>
<div id="outline-container-results-full" class="outline-3">
<h3 id="results-full"><span class="section-number-3">3.1.</span> Full search</h3>
<div class="outline-text-3" id="text-results-full">
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">optimal</th>
<th scope="col" class="org-right">unique</th>
<th scope="col" class="org-right">unique chains</th>
<th scope="col" class="org-right">chains generated</th>
<th scope="col" class="org-right">computation</th>
<th scope="col" class="org-right">progress</th>
<th scope="col" class="org-right">capacity</th>
</tr>

<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">length</th>
<th scope="col" class="org-right">function sets</th>
<th scope="col" class="org-right">&#xa0;</th>
<th scope="col" class="org-right">&#xa0;</th>
<th scope="col" class="org-right">time</th>
<th scope="col" class="org-right">&#xa0;</th>
<th scope="col" class="org-right">&#xa0;</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">10 digits</td>
<td class="org-right">11</td>
<td class="org-right">3</td>
<td class="org-right">40</td>
<td class="org-right">7,461,658</td>
<td class="org-right">0.03 secs</td>
<td class="org-right">100%</td>
<td class="org-right">MacBook Air 15" (M2, 2023)</td>
</tr>

<tr>
<td class="org-left">11 digits</td>
<td class="org-right">12</td>
<td class="org-right">91</td>
<td class="org-right">1,079</td>
<td class="org-right">344,252,541</td>
<td class="org-right">0.78 secs</td>
<td class="org-right">100%</td>
<td class="org-right">MacBook Air 15" (M2, 2023)</td>
</tr>

<tr>
<td class="org-left">12 digits</td>
<td class="org-right">14</td>
<td class="org-right">6</td>
<td class="org-right">75</td>
<td class="org-right">263,675,232,692</td>
<td class="org-right">9 mins</td>
<td class="org-right">100%</td>
<td class="org-right">MacBook Air 15" (M2, 2023)</td>
</tr>

<tr>
<td class="org-left">13 digits</td>
<td class="org-right">15</td>
<td class="org-right">1</td>
<td class="org-right">4</td>
<td class="org-right">15,586,512,093,540</td>
<td class="org-right">7.6 hours</td>
<td class="org-right">100%</td>
<td class="org-right">MacBook Air 15" (M2, 2023)</td>
</tr>

<tr>
<td class="org-left">14 digits</td>
<td class="org-right">16</td>
<td class="org-right">35</td>
<td class="org-right">71</td>
<td class="org-right">1,172,393,232,657,510</td>
<td class="org-right">156 days</td>
<td class="org-right">100%</td>
<td class="org-right">AWS ECS, 1 vCPU/job</td>
</tr>

<tr>
<td class="org-left">15 digits</td>
<td class="org-right">17</td>
<td class="org-right">[so far] 1</td>
<td class="org-right">1</td>
<td class="org-right">30,968,277,080,052,517</td>
<td class="org-right">1,436 days</td>
<td class="org-right">&lt;40%</td>
<td class="org-right">AWS ECS, 1 vCPU/job</td>
</tr>

<tr>
<td class="org-left">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">&#xa0;</td>
<td class="org-right">20,746,530,220,101,114</td>
<td class="org-right">1,147 days</td>
<td class="org-right">+&lt;32%</td>
<td class="org-right">BOINC Central, various</td>
</tr>
</tbody>
</table>
<p>
Note: those times and numbers are based on the full search version that didn&rsquo;t
yet stop the branch after finding a target function; the number of chains to
generate then reduces to about 56-59% of the figures here.
An exception is the 15-digit run, which started with the old version for the
first 10%, then switched to the new version to save time.
</p>

<p>
Thanks to <a href="https://boinc.berkeley.edu/central/">BOINC Central</a> for providing computing capacity for this search!
</p>
</div>
</div>
<div id="outline-container-results-hungry" class="outline-3">
<h3 id="results-hungry"><span class="section-number-3">3.2.</span> Hungry search</h3>
<div class="outline-text-3" id="text-results-hungry">
<p>
With bite sizes 15, 14, 13, &#x2026;
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">length</th>
<th scope="col" class="org-right">chains found</th>
<th scope="col" class="org-right">unique chains</th>
<th scope="col" class="org-right">chains generated</th>
<th scope="col" class="org-right">computation time</th>
<th scope="col" class="org-right">capacity</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">10 digits</td>
<td class="org-right">12</td>
<td class="org-right">1,387</td>
<td class="org-right">78,595</td>
<td class="org-right">200,246</td>
<td class="org-right">3.11 secs</td>
<td class="org-right">MacBook Air 15" (M2, 2023)</td>
</tr>

<tr>
<td class="org-left">11 digits</td>
<td class="org-right">12</td>
<td class="org-right">192</td>
<td class="org-right">578</td>
<td class="org-right">221,833</td>
<td class="org-right">7.55 secs</td>
<td class="org-right">MacBook 15" Air (M2, 2023)</td>
</tr>

<tr>
<td class="org-left">12 digits</td>
<td class="org-right">14</td>
<td class="org-right">3</td>
<td class="org-right">19</td>
<td class="org-right">6,182,486</td>
<td class="org-right">15 mins</td>
<td class="org-right">MacBook 15" Air (M2, 2023)</td>
</tr>

<tr>
<td class="org-left">16 digits</td>
<td class="org-right">18</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">956,653,260</td>
<td class="org-right">302 days</td>
<td class="org-right">AWS ECS, 1 vCPU/job</td>
</tr>
</tbody>
</table>

<p>
With bite sizes 10, 9, 8, &#x2026;
</p>
<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-left" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-left">&#xa0;</th>
<th scope="col" class="org-right">length</th>
<th scope="col" class="org-right">chains found</th>
<th scope="col" class="org-right">unique chains</th>
<th scope="col" class="org-right">chains generated</th>
<th scope="col" class="org-right">computation time</th>
<th scope="col" class="org-right">capacity</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-left">15 digits</td>
<td class="org-right">17</td>
<td class="org-right">0</td>
<td class="org-right">0</td>
<td class="org-right">8,231,903</td>
<td class="org-right">7 days</td>
<td class="org-right">AWS ECS, 1 vCPU/job</td>
</tr>

<tr>
<td class="org-left">15 digits</td>
<td class="org-right">18</td>
<td class="org-right">493</td>
<td class="org-right">428</td>
<td class="org-right">11,237,970</td>
<td class="org-right">14 hours</td>
<td class="org-right">AWS ECS, 1 vCPU/job</td>
</tr>

<tr>
<td class="org-left">16 digits</td>
<td class="org-right">19</td>
<td class="org-right">34</td>
<td class="org-right">11</td>
<td class="org-right">31,163,144</td>
<td class="org-right">98 days</td>
<td class="org-right">AWS ECS, 1 vCPU/job</td>
</tr>
</tbody>
</table>
<p>
Note: the 15 digits search for length 18 is noticeably faster than the one for
length 17, this is because the one for length 18 already employed the
optimization of avoiding Algorithm U if the next step must be a target function.
</p>
</div>
</div>
<div id="outline-container-results-branching" class="outline-3">
<h3 id="results-branching"><span class="section-number-3">3.3.</span> Branching</h3>
<div class="outline-text-3" id="text-results-branching">
<p>
I tracked some statistics on the number of new instructions encountered at
different lengths and the number of chains generated. For the decimal display
for 13 digits, searching to a maximal length of \(m=19\) the program looked at
15,586,512,093,540 chains,
The exact number depends on the order in which instructions are generated, and
the following table provides some statistics on the number of newly added
instructions at every length.
</p>

<p>
The main takeaway is that the branching factor doesn&rsquo;t grow much as the chains
get longer, because so many instructions result in the same functions and we
ignore different orders of the same set of functions. The table is slightly
misleading, however, as the number of actual branches will be roughly the sum of
these newly added instructions up to that length, e.g. at length 8 on average
\(30+8+10+11+12 = 71\).
</p>

<p>
That the numbers go down again after length 12 is due to the algorithm stopping
at a max length of 19 and bailing out once a chain has no hope of generating all
7 target functions by length 10 anymore (12 = 19 - 7 target functions). So fewer
and fewer branches make it to those higher lengths.
</p>

<table border="2" cellspacing="0" cellpadding="6" rules="groups" frame="hsides">


<colgroup>
<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />

<col  class="org-right" />
</colgroup>
<thead>
<tr>
<th scope="col" class="org-right">c</th>
<th scope="col" class="org-right">chains</th>
<th scope="col" class="org-right">sum new instructions</th>
<th scope="col" class="org-right">avg</th>
<th scope="col" class="org-right">min</th>
<th scope="col" class="org-right">max</th>
</tr>
</thead>
<tbody>
<tr>
<td class="org-right">4</td>
<td class="org-right">1</td>
<td class="org-right">30</td>
<td class="org-right">30</td>
<td class="org-right">30</td>
<td class="org-right">30</td>
</tr>

<tr>
<td class="org-right">5</td>
<td class="org-right">30</td>
<td class="org-right">252</td>
<td class="org-right">8</td>
<td class="org-right">2</td>
<td class="org-right">10</td>
</tr>

<tr>
<td class="org-right">6</td>
<td class="org-right">687</td>
<td class="org-right">6881</td>
<td class="org-right">10</td>
<td class="org-right">3</td>
<td class="org-right">15</td>
</tr>

<tr>
<td class="org-right">7</td>
<td class="org-right">15349</td>
<td class="org-right">170840</td>
<td class="org-right">11</td>
<td class="org-right">2</td>
<td class="org-right">20</td>
</tr>

<tr>
<td class="org-right">8</td>
<td class="org-right">362425</td>
<td class="org-right">4448336</td>
<td class="org-right">12</td>
<td class="org-right">1</td>
<td class="org-right">25</td>
</tr>

<tr>
<td class="org-right">9</td>
<td class="org-right">9341932</td>
<td class="org-right">127672810</td>
<td class="org-right">13</td>
<td class="org-right">1</td>
<td class="org-right">30</td>
</tr>

<tr>
<td class="org-right">10</td>
<td class="org-right">266485149</td>
<td class="org-right">4055025721</td>
<td class="org-right">15</td>
<td class="org-right">0</td>
<td class="org-right">33</td>
</tr>

<tr>
<td class="org-right">11</td>
<td class="org-right">8442288161</td>
<td class="org-right">141892395181</td>
<td class="org-right">16</td>
<td class="org-right">0</td>
<td class="org-right">38</td>
</tr>

<tr>
<td class="org-right">12</td>
<td class="org-right">296360074644</td>
<td class="org-right">5451011054514</td>
<td class="org-right">18</td>
<td class="org-right">0</td>
<td class="org-right">43</td>
</tr>

<tr>
<td class="org-right">13</td>
<td class="org-right">67539256837</td>
<td class="org-right">1281813235039</td>
<td class="org-right">18</td>
<td class="org-right">0</td>
<td class="org-right">46</td>
</tr>

<tr>
<td class="org-right">14</td>
<td class="org-right">29625227652</td>
<td class="org-right">564173170164</td>
<td class="org-right">19</td>
<td class="org-right">0</td>
<td class="org-right">51</td>
</tr>

<tr>
<td class="org-right">15</td>
<td class="org-right">1038462604</td>
<td class="org-right">23435424999</td>
<td class="org-right">22</td>
<td class="org-right">0</td>
<td class="org-right">53</td>
</tr>

<tr>
<td class="org-right">16</td>
<td class="org-right">27930118</td>
<td class="org-right">762860238</td>
<td class="org-right">27</td>
<td class="org-right">2</td>
<td class="org-right">54</td>
</tr>

<tr>
<td class="org-right">17</td>
<td class="org-right">255268</td>
<td class="org-right">7328660</td>
<td class="org-right">28</td>
<td class="org-right">5</td>
<td class="org-right">51</td>
</tr>

<tr>
<td class="org-right">18</td>
<td class="org-right">1282</td>
<td class="org-right">39984</td>
<td class="org-right">31</td>
<td class="org-right">16</td>
<td class="org-right">45</td>
</tr>
</tbody>
</table>
</div>
</div>
</div>
<div id="outline-container-best-chains" class="outline-2">
<h2 id="best-chains"><span class="section-number-2">4.</span> Best chains</h2>
<div class="outline-text-2" id="text-best-chains">
</div>
<div id="outline-container-10-digits" class="outline-3">
<h3 id="10-digits"><span class="section-number-3">4.1.</span> Seven-segment display for 10 digits</h3>
<div class="outline-text-3" id="text-10-digits">
\begin{aligned}
    x_5    &= x_1  \lor   x_2                   & \quad
    x_9    &= x_5  <      x_8    = \overline{f} & \quad
    x_{13} &= x_3  <      x_{10} = \overline{a} & \\

    x_6    &= x_3  \oplus x_5                   & \quad
    x_{10} &= x_6  \oplus x_8    = \overline{d} & \quad
    x_{14} &= x_4  \lor   x_{10} = \overline{e} & \\

    x_7    &= x_2  <      x_6                   & \quad
    x_{11} &= x_4  <      x_9    = \overline{c} & \quad
    x_{15} &= x_6  \lor   x_{12} = g            & \\

    x_8    &= x_4  \lor   x_7                   & \quad
    x_{12} &= x_2  >      x_{10} = \overline{b} & \\
\end{aligned}


<div id="orgde0dc76" class="figure">
<p><img src="./10-digits-segments.svg" alt="10-digits-segments.svg" class="org-svg" width="550px" />
</p>
</div>

<p>
All 40 unique optimal chains of length 11: <a href="chains-10-15.txt">chains-10-15.txt</a>
</p>
</div>
</div>
<div id="outline-container-11-digits" class="outline-3">
<h3 id="11-digits"><span class="section-number-3">4.2.</span> Seven-segment display for 11 digits</h3>
<div class="outline-text-3" id="text-11-digits">
\begin{aligned}
    x_5    &= x_1    \lor   x_2                   & \quad
    x_9    &= x_3    \oplus x_7                   & \quad
    x_{13} &= x_9    \oplus x_{10} = \overline{d} & \\

    x_6    &= x_1    \oplus x_3                   & \quad
    x_{10} &= x_5    <      x_8    = \overline{f} & \quad
    x_{14} &= x_3    <      x_{13} = \overline{a} & \\

    x_7    &= x_2    >      x_4                   & \quad
    x_{11} &= x_2    >      x_9    = \overline{b} & \quad
    x_{15} &= x_8    \oplus x_{13} = g            & \\

    x_8    &= x_4    \lor   x_6                   & \quad
    x_{12} &= x_4    <      x_{10} = \overline{c} & \quad
    x_{16} &= x_4    \lor   x_{14} = \overline{e} & \\

\end{aligned}


<div id="org39d9312" class="figure">
<p><img src="./11-digits-segments.svg" alt="11-digits-segments.svg" class="org-svg" width="550px" />
</p>
</div>

<p>
All 1,079 unique optimal chains of length 12: <a href="chains-11-16.txt">chains-11-16.txt</a>
</p>
</div>
</div>
<div id="outline-container-12-digits" class="outline-3">
<h3 id="12-digits"><span class="section-number-3">4.3.</span> Seven-segment display for 12 digits</h3>
<div class="outline-text-3" id="text-12-digits">
\begin{aligned}
    x_5    &= x_1    \oplus x_3                   & \quad
    x_{10} &= x_3    \oplus x_9                   & \quad
    x_{15} &= x_7    \lor   x_{13} = g            & \\

    x_6    &= x_3    \oplus x_4                   & \quad
    x_{11} &= x_5    <      x_{10} = \overline{a} & \quad
    x_{16} &= x_9    <      x_{13} = \overline{b} & \\

    x_7    &= x_2    <      x_5                   & \quad
    x_{12} &= x_6    \lor   x_{11}                & \quad
    x_{17} &= x_{10} >      x_{13} = \overline{f} & \\

    x_8    &= x_6    >      x_7                   & \quad
    x_{13} &= x_8    \oplus x_{11}                & \quad
    x_{18} &= x_4    <      x_{17} = \overline{c} & \\

    x_9    &= x_2    \oplus x_8    = \overline{d} & \quad
    x_{14} &= x_3    \oplus x_{12} = \overline{e} & \\
\end{aligned}


<div id="orga84defc" class="figure">
<p><img src="./12-digits-segments.svg" alt="12-digits-segments.svg" class="org-svg" width="550px" />
</p>
</div>

<p>
All 75 unique optimal chains of length 14: <a href="chains-12-18.txt">chains-12-18.txt</a>
</p>
</div>
</div>
<div id="outline-container-13-digits" class="outline-3">
<h3 id="13-digits"><span class="section-number-3">4.4.</span> Seven-segment display for 13 digits</h3>
<div class="outline-text-3" id="text-13-digits">
\begin{aligned}
    x_5    &= x_2    \oplus x_3                   & \quad
    x_{10} &= x_5    \lor   x_9    = g            & \quad
    x_{15} &= x_6    \land  x_{14} = \overline{a} & \\

    x_6    &= x_2    \oplus x_4                   & \quad
    x_{11} &= x_7    >      x_9    = \overline{f} & \quad
    x_{16} &= x_9    \land  x_{15}                & \\

    x_7    &= x_5    \lor   x_6                   & \quad
    x_{12} &= x_4    <      x_{11} = \overline{c} & \quad
    x_{17} &= x_4    \oplus x_{16} = \overline{e} & \\

    x_8    &= x_2    \land  x_7                   & \quad
    x_{13} &= x_8    \lor   x_{11}                & \quad
    x_{18} &= x_8    \oplus x_{16} = \overline{b} & \\

    x_9    &= x_1    \oplus x_8                   & \quad
    x_{14} &= x_3    \oplus x_{13}                & \quad
    x_{19} &= x_{14} >      x_{18} = \overline{d} & \\

\end{aligned}


<div id="org687d34f" class="figure">
<p><img src="./13-digits-segments.svg" alt="13-digits-segments.svg" class="org-svg" width="550px" />
</p>
</div>

<p>
All 4 unique optimal chains of length 15: <a href="chains-13-19.txt">chains-13-19.txt</a>
</p>
</div>
</div>
<div id="outline-container-14-digits" class="outline-3">
<h3 id="14-digits"><span class="section-number-3">4.5.</span> Seven-segment display for 14 digits</h3>
<div class="outline-text-3" id="text-14-digits">
\begin{aligned}
    x_5    &= x_1    \oplus x_2                   & \quad
    x_{11} &= x_5    <      x_9    = \overline{f} & \quad
    x_{17} &= x_{13} <      x_{14} = \overline{d} & \\

    x_6    &= x_1    \oplus x_4                   & \quad
    x_{12} &= x_8    \oplus x_9    = \overline{a} & \quad
    x_{18} &= x_5    <      x_{15} = \overline{c} & \\

    x_7    &= x_3    \oplus x_4                   & \quad
    x_{13} &= x_2    \oplus x_{10}                & \quad
    x_{19} &= x_{13} \land  x_{15} = \overline{b} & \\

    x_8    &= x_3    \lor   x_5                   & \quad
    x_{14} &= x_6    \lor   x_{12}                & \quad
    x_{20} &= x_{13} \lor   x_{15} = g            & \\

    x_9    &= x_6    \lor   x_7                   & \quad
    x_{15} &= x_7    \oplus x_{12}                & \\

    x_{10} &= x_7    <      x_8                   & \quad
    x_{16} &= x_1    \oplus x_{14} = \overline{e} & \\
\end{aligned}

<p>
This chain almost solves the 15 or even 16 digit case, with the top-left segment
missing from the <code>E</code> and the top segment of the <code>F</code> slipped to the top-right. So
close!
</p>


<div id="org3bfd911" class="figure">
<p><img src="./14-digits-segments.svg" alt="14-digits-segments.svg" class="org-svg" width="550px" />
</p>
</div>

<p>
All 71 unique optimal chains of length 16: <a href="chains-14-20.txt">chains-14-20.txt</a>
</p>
</div>
</div>
<div id="outline-container-15-digits" class="outline-3">
<h3 id="15-digits"><span class="section-number-3">4.6.</span> Seven-segment display for 15 digits</h3>
<div class="outline-text-3" id="text-15-digits">
\begin{aligned}
    x_5    &= x_2    \land  x_3                   & \quad
    x_{12} &= x_7    <      x_{10} = \overline{d} & \quad
    x_{19} &= x_8    \lor   x_{16}                & \\

    x_6    &= x_1    \lor   x_5                   & \quad
    x_{13} &= x_2    \oplus x_{11}                & \quad
    x_{20} &= x_6    \oplus x_{19} = \overline{e} & \\

    x_7    &= x_3    \oplus x_6                   & \quad
    x_{14} &= x_{11} \oplus x_{12} = g            & \quad
    x_{21} &= x_{10} <      x_{19} = \overline{b} & \\

    x_8    &= x_4    \oplus x_6                   & \quad
    x_{15} &= x_1    \oplus x_{13}                & \\

    x_9    &= x_4    \lor   x_7                   & \quad
    x_{16} &= x_7    \oplus x_{13} = \overline{a} & \\

    x_{10} &= x_2    \oplus x_8                   & \quad
    x_{17} &= x_9    \land  x_{15} = \overline{f} & \\

    x_{11} &= x_5    \lor   x_9                   & \quad
    x_{18} &= x_{10} <      x_{15} = \overline{c} & \\
\end{aligned}


<div id="org66b00cd" class="figure">
<p><img src="./15-digits-segments.svg" alt="15-digits-segments.svg" class="org-svg" width="550px" />
</p>
</div>

<p>
1 unique optimal set of functions of length 17: <a href="chains-15-21.txt">chains-15-21.txt</a>
</p>

<p>
428 unique chains of length 18 that the hungry search found: <a href="chains-15-22.txt">chains-15-22.txt</a>.
</p>
</div>
</div>
<div id="outline-container-16-digits" class="outline-3">
<h3 id="16-digits"><span class="section-number-3">4.7.</span> Seven-segment display for 16 digits</h3>
<div class="outline-text-3" id="text-16-digits">
<p>
A chain of length 19 found by the hungry search:
</p>

\begin{aligned}
    x_5    &= x_3    <      x_4                   & \quad
    x_{12} &= x_1    \lor   x_{11}                & \quad
    x_{19} &= x_8    >      x_{18} = \overline{a} & \\

    x_6    &= x_3    \oplus x_4                   & \quad
    x_{13} &= x_7    \lor   x_{12} = g            & \quad
    x_{20} &= x_4    \oplus x_{14}                & \\

    x_7    &= x_2    \oplus x_3                   & \quad
    x_{14} &= x_7    >      x_{11}                & \quad
    x_{21} &= x_{16} <      x_{20} = \overline{e} & \\

    x_8    &= x_5    \lor   x_7                   & \quad
    x_{15} &= x_2    \oplus x_{14}                & \quad
    x_{22} &= x_{19} \oplus x_{20}                & \\

    x_9    &= x_1    \oplus x_2                   & \quad
    x_{16} &= x_9    <      x_{15} = \overline{c} & \quad
    x_{23} &= x_8    \oplus x_{22} = \overline{d} & \\

    x_{10} &= x_8    >      x_9    = \overline{f} & \quad
    x_{17} &= x_{12} \land  x_{15} = \overline{b} & \\

    x_{11} &= x_6    \oplus x_{10}                & \quad
    x_{18} &= x_{11} \oplus x_{16}                & \\
\end{aligned}

<p>
11 unique chains of length 19 that the hungry search found: <a href="chains-16-23.txt">chains-16-23.txt</a>, not
exhaustive, not proven to be optimal.
</p>


<div id="orgc817917" class="figure">
<p><img src="./16-digits-segments.svg" alt="16-digits-segments.svg" class="org-svg" width="550px" />
</p>
</div>
</div>
</div>
<div id="outline-container-7.1.2-54" class="outline-3">
<h3 id="7.1.2-54"><span class="section-number-3">4.8.</span> Exercise 7.1.2-54</h3>
<div class="outline-text-3" id="text-7.1.2-54">
<p>
Total chains generated: 934,236,665,700
</p>

<p>
Number of unique optimal sets of functions: 1270
</p>

<p>
The minimal length is 13, one step shorter than the solution known in the book.
</p>

<p>
Here is the first one found:
</p>

\begin{aligned}
    x_5    &= x_1    \land  x_2          & \quad
    x_{10} &= x_4    >      x_7          & \quad
    x_{15} &= x_7    \land  x_{11} = f_1 & \\

    x_6    &= x_1    \oplus x_3          & \quad
    x_{11} &= x_6    \oplus x_8          & \quad
    x_{16} &= x_9    >      x_{13} = f_3 & \\

    x_7    &= x_2    \oplus x_3          & \quad
    x_{12} &= x_5    \land  x_9    = f_5 & \quad
    x_{17} &= x_4    \land  x_{15} = f_6 & \\

    x_8    &= x_4    \lor   x_5          & \quad
    x_{13} &= x_1    \land  x_{10} = f_4 & \\

    x_9    &= x_4    \land  x_6          & \quad
    x_{14} &= x_6    <      x_{10} = f_2 & \\
\end{aligned}
</div>
</div>
<div id="outline-container-7.1.2-59" class="outline-3">
<h3 id="7.1.2-59"><span class="section-number-3">4.9.</span> Exercise 7.1.2-59</h3>
<div class="outline-text-3" id="text-7.1.2-59">
<p>
Hungry search found chains of length 15, two steps shorter than the one in the
book, but no guarantees that it is minimal.
</p>

<p>
Here is the first one found:
</p>

\begin{aligned}
    x_5    &= x_2    \oplus x_4          & \quad
    x_{10} &= x_6    <      x_9          & \quad
    x_{15} &= x_1    >      x_{14}       & \\

    x_6    &= x_2    \oplus x_3          & \quad
    x_{11} &= x_7    \oplus x_{10} = f_3 & \quad
    x_{16} &= x_6    >      x_{15}       & \\

    x_7    &= x_1    \oplus x_5          & \quad
    x_{12} &= x_3    \land  x_7          & \quad
    x_{17} &= x_{12} \lor   x_{16} = f_4 & \\

    x_8    &= x_4    <      x_7          & \quad
    x_{13} &= x_5    \lor   x_{12}       & \quad
    x_{18} &= x_{12} \oplus x_{16}       & \\

    x_9    &= x_3    \oplus x_8          & \quad
    x_{14} &= x_9    \oplus x_{13} = f_2 & \quad
    x_{19} &= x_9    \oplus x_{18} = f_1 & \\
\end{aligned}
</div>
</div>
</div>
<div id="outline-container-source-code" class="outline-2">
<h2 id="source-code"><span class="section-number-2">5.</span> Source code</h2>
<div class="outline-text-2" id="text-source-code">
<p>
The code can be found on GitHub: <a href="https://github.com/or/boolean-chains">https://github.com/or/boolean-chains</a>
</p>

<p>
Initially I used this to learn a bit of Rust, then re-implemented it in C++,
then switched over to C++ completely as I made better progress. I wonder whether
it could be even faster in Rust, however, if written by someone who knows Rust
better than me.
</p>
</div>
</div>
</div>
<div id="postamble" class="status">
<p class="date">Date: 2025-03-01 Sat 00:00</p>
<p class="author">Author: Oliver Runge</p>
<p class="date">Created: 2025-05-08 Thu 16:18</p>
</div>
</body>
</html>
